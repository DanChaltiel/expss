% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/selectors.R
\docType{data}
\name{vars}
\alias{vars}
\alias{._}
\alias{vars_list}
\alias{indirect}
\alias{indirect_list}
\alias{\%to\%}
\alias{\%to_list\%}
\alias{.internal_to_}
\title{Get variables/range of variables by name/by pattern.}
\format{An object of class \code{parameter} of length 1.}
\usage{
vars(...)

._

vars_list(...)

indirect(...)

indirect_list(...)

e1 \%to\% e2

e1 \%to_list\% e2

.internal_to_(e1, e2)
}
\arguments{
\item{...}{characters names of variables or criteria/logical functions}

\item{e1}{unquoted name of start variable (e. g. a_1)}

\item{e2}{unquoted name of start variable (e. g. a_5)}
}
\value{
data.frame/list with variables
}
\description{
\itemize{
\item{\code{vars}}{ returns all variables by their names or by criteria (see 
\link{criteria}). There is no non-standard evaluation in this function by
design so use quotes for names of your variables or use \link{qc}. The only
exception with non-standard evaluation is \code{\%to\%}. You can use
\code{\%to\%} inside \code{vars} or independently.}
\item{\code{\%to\%}}{ returns range of variables between \code{e1} and 
\code{e2} (similar to SPSS 'to'). \link{modify}, \link{modify_if}, 
\link{calculate}, \link{keep}, \link{except} and \link{where} support 
\code{\%to\%}. Inside global environment \link[base]{with},
\link[base]{within} \code{\%to\%} will take range from names of variables
sorted in the alphabetic order.}
\item{\code{indirect}}{ are aliases for
\code{vars}/\code{vars_list}.}
}
Functions with word 'list' in name return lists of variables instead of 
dataframes.
\code{.internal_to_} is for internal usage and not documented.
}
\examples{
# In data.frame
dfs = data.frame(
    a = rep(10, 5),
    b_1 = rep(11, 5),
    b_2 = rep(12, 5),
    b_3 = rep(13, 5),
    b_4 = rep(14, 5),
    b_5 = rep(15, 5) 
)

# calculate sum of b_* variables
compute(dfs, {
    b_total = sum_row(b_1 \%to\% b_5)
})

# In global environement
a = rep(10, 5)
a1 = rep(1, 5)
a2 = rep(2, 5)
a3 = rep(3, 5)
a4 = rep(4, 5)
a5 = rep(5, 5)

# identical results
a1 \%to\% a5
vars(perl("^a[0-9]$"))

# sum each row
sum_row(a1 \%to\% a5)

# variable substitution
name1 = "a"
name2 = "new_var"

# example with short notation but it can be applied only for simple cases - 
# when 'name' is vector of length 1
compute(dfs, {
     ._$name2 = ._$name1*2    
})

compute(dfs, {
     for(name1 in paste0("b_", 1:5)){
         name2 = paste0("new_", name1) 
         ._$name2 = ._$name1*2 
     }
     rm(name1, name2) # we don't need this variables as columns in 'dfs'
})

# square brackets notation
compute(dfs, {
     ._[name2] = ._[name1]*2  
})

compute(dfs, {
     for(name1 in paste0("b_", 1:5)){
         ._[paste0("new_", name1)] = ._$name1*2 
     }
     rm(name1) # we don't need this variable as column in 'dfs'
})

# '._$' doesn't work for case below so we need to use square brackets form
name1 = paste0("b_", 1:5)
name2 = paste0("new_", name1)
compute(dfs, {
     for(i in 1:5){
         ._[name2[i]] = ._[name1[i]]*3
     }
     rm(i) # we don't need this variable as column in 'dfs'
})

}
\seealso{
\link{keep}, \link{except}, \link{do_repeat}, \link{compute}
}
\keyword{datasets}
