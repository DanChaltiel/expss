% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count_if.R
\name{count_if}
\alias{\%in_col\%}
\alias{\%in_row\%}
\alias{apply_col_if}
\alias{apply_row_if}
\alias{count_col_if}
\alias{count_if}
\alias{count_row_if}
\alias{max_col_if}
\alias{max_if}
\alias{max_row_if}
\alias{mean_col_if}
\alias{mean_if}
\alias{mean_row_if}
\alias{median_col_if}
\alias{median_if}
\alias{median_row_if}
\alias{min_col_if}
\alias{min_if}
\alias{min_row_if}
\alias{sd_col_if}
\alias{sd_if}
\alias{sd_row_if}
\alias{sum_col_if}
\alias{sum_if}
\alias{sum_row_if}
\title{Count/sum/average/other functions on values that meet a criterion that you specify}
\usage{
count_if(criterion = NULL, ...)

count_row_if(criterion = NULL, ...)

count_col_if(criterion = NULL, ...)

criterion \%in_row\% x

criterion \%in_col\% x

sum_if(criterion = NULL, ..., data = NULL)

sum_row_if(criterion = NULL, ..., data = NULL)

sum_col_if(criterion = NULL, ..., data = NULL)

mean_if(criterion = NULL, ..., data = NULL)

mean_row_if(criterion = NULL, ..., data = NULL)

mean_col_if(criterion = NULL, ..., data = NULL)

sd_if(criterion = NULL, ..., data = NULL)

sd_row_if(criterion = NULL, ..., data = NULL)

sd_col_if(criterion = NULL, ..., data = NULL)

median_if(criterion = NULL, ..., data = NULL)

median_row_if(criterion = NULL, ..., data = NULL)

median_col_if(criterion = NULL, ..., data = NULL)

max_if(criterion = NULL, ..., data = NULL)

max_row_if(criterion = NULL, ..., data = NULL)

max_col_if(criterion = NULL, ..., data = NULL)

min_if(criterion = NULL, ..., data = NULL)

min_row_if(criterion = NULL, ..., data = NULL)

min_col_if(criterion = NULL, ..., data = NULL)

apply_row_if(fun, criterion = NULL, ..., data = NULL)

apply_col_if(fun, criterion = NULL, ..., data = NULL)
}
\arguments{
\item{criterion}{Vector with counted values, list with conditions or
function. If criterion is missing (or is NULL) non-NA's values will be
used for function.}

\item{...}{Data on which criterion will be applied. Vector, matrix,
data.frame, list. Shorter arguments will be recycled.}

\item{x}{Counted values or criterion for counting. Vector, matrix, data.frame,
list, function. Shorter columns in list will be recycled.}

\item{data}{Data on which function will be applied. Doesn't applicable to
\code{count_*_if} functions. If omitted function will be applied on the ...
argument.}

\item{fun}{Custom function that will be applied based on criterion.}
}
\value{
\code{count_if} return single value (vector of length 1). 
\code{count_row_if} returns vector of counts for each row of supplied arguments.
\code{count_col_if} returns vector of counts for each column of supplied arguments.
\code{\%in_row\%}/\code{\%in_col\%} return logical vector - presence
indicator of criterion in each row/column.
}
\description{
There are two flavors of this function - one works with entire dataset/matrix/vector
similar to Microsoft Excel \code{COUNTIF}. The second works rowwise(columnwise) - e. g. 
similar to SPSS \code{COUNT} function.
}
\details{
\code{count_if} counts values in entire dataset and return single 
value (vector of length 1).

\code{count_row_if} counts values in each row of supplied arguments and return
vector of counts for each row of supplied arguments.

\code{count_col_if} counts values in each column of supplied arguments and return
vector of counts for each column of supplied arguments.

All functions never return NA's. 

If criterion is list, then each element considered as single condition and
they will be combined with AND.

Function criterion should return logicals of same size and shape as its argument.
This function will be applied to each column of supplied data and TRUE results will be counted.
There is asymmetrical behavior in \code{count_row_if} and
\code{count_col_if}: in both cases function criterion will be applied
columnwise.
There are special functions for usage as criteria (e. g. \code{gt(5)} is
equivalent ">5" in spreadsheet) - see \link{eq}:
}
\examples{
set.seed(123)
dfs = as.data.frame(
       matrix(sample(c(1:10,NA),30,replace = TRUE),10)
)

result  = modify(dfs, {
                   exact = count_row_if(8, V1, V2, V3)
                   greater = count_row_if(gt(8), V1, V2, V3)
                   range = count_row_if(5:8, V1, V2, V3)
                   na = count_row_if(is.na, V1, V2, V3)
                   not_na = count_row_if(, V1, V2, V3)
                })  
result
 
mean_row_if(6, dfs$V1, data = dfs)
median_row_if(gt(2), dfs$V1, dfs$V2, dfs$V3) 
sd_row_if(5 \%thru\% 8, dfs$V1, dfs$V2, dfs$V3)
 
if_na(dfs) = 5 # replace NA 

# custom apply
apply_col_if(prod, gt(2), dfs$V1, data = dfs) # product of all elements by columns
apply_row_if(prod, gt(2), dfs$V1, data = dfs) # product of all elements by rows
 
# Examples borrowed from Microsoft Excel help for COUNTIF
df1 = data.frame(
    a=c("apples",   "oranges",     "peaches",     "apples"),
    b = c(32, 54, 75, 86)
)

count_if("apples",df1$a) # 2

count_if("apples",df1) # 2

with(df1,count_if("apples",a,b)) # 2

count_if(gt(55),df1$b) # greater than 55 = 2

count_if(neq(75),df1$b) # not equal 75 = 3

count_if(gte(32),df1$b) # greater than or equal 32 = 4

count_if(gt(32) & lt(86),df1$b) # 2

# count only integer values between 33 and 85
count_if(33:85,df1$b) # 2

# values with letters
count_if(regex("^[A-z]+$"),df1) # 4

# values that started on 'a'
count_if(regex("^a"),df1) # 2

# count_row_if
count_row_if(regex("^a"),df1) # c(1,0,0,1)

'apples' \%in_row\% df1  # c(TRUE,FALSE,FALSE,TRUE)

}

